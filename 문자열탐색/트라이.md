# 트라이

    Trie

## 개요

 여러개의 문자열을 탐색하기 위해선 시간이 많이 소묘되며, 특히 삭제와 삽입이 빈번한 경우 더 많은 시간이 걸린다.
 힙을 이용한 정렬 및 배열을 정렬하여 문자열을 빠르게 탐색할 수 있지만, 이 경우에도 N에 영향받게 되어 많은 시간이 걸린다.

### 비교

    1. 힙을 사용한 정렬(set, map): 탐색, 삽입, 삭제에 log(N)이 걸린다.
    2. vector을 사용한 정렬: sort(vector) : 탐색에 O(1), 삽입에 O(1), 정렬에 NlogN이 걸린다.
    3. lowerbound를 사용한 정렬: 탐색에 log N, 삽입에 N, 삭제에 N이 걸린다.
    4. **Trie를 사용하여 삽입, 삭제, 탐색에 글자 길이(M) 이 걸리게 한다.**
    
    

 
 

 
## 방법

1. DFS, BFS를 통해 노드를 탐색한다.
2. 이 탐색에 더 이상 가치가 없는 경우 도중에 중단한다.
3. 결과 노드를 찾는다.

## 요약(DFS 이미지 가져옴)
![DFS](./이미지/DFS.png) 

## 예제 코드


```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;
#define MAX 500

vector<int> graph[MAX];
int visit[MAX]; //방문할 개수이다.

void DFS(int start){
  //start 지점을 방문처리한다.
  visit[start] = true;
  for(auto i : graph[start]){
    if(!visit[i]){ // 길이 연결되어 있고 동시에, 이 i번째 노드에 방문한 적이 있는지 확인한다.
      //만약, 방문한적이 없고 길이 이어져 있다면,
      DFS(i);
    }
  }
}
int main(){
  //두가지 방식을 사용하였다(코드 테크닉)
   DFS(0);
}
```

## 활용

1. 완전 탐색을 하되, 깊이 우선 탐색이 전략적으로 필요한 경우
